-- These 'include guards' are necessary because some of the
-- sub-components were written to be used elsewhere and thus
-- may already be imported. Actually, now that I think about it, if they
-- are imported into local vars elswhere, then this is entirely
-- unnecessary. Eh, it isn't hurting anybody. Leaving it in.
local TileGrid
local disorder
local InputGetter

if not TileGrid then TileGrid = require 'stp/TileGrid' end
if not disorder then disorder  = require 'stp/Disorder' end
if not InputGetter then InputGetter = require 'stp/InputGetter' end

-- Forward declarations - consider the following list the Lua
-- equivalent of a C header file. Anyone who uses Lua knows that
-- functions' symbol names need to actually exist before they can be
-- referenced in a function body, even if the function itself isn't
-- invoked until later. This satisfies that, and allows me to communicate
-- how the functions are related and the general order they are used in.
-- If I didn't do this, I would have to define the functions in an order
-- opposite to how high-level they are, which feels wrong.

-- Pre-puzzle functions
local run
local initLegalInputs
local commandInputsMap
local initInputGetters
local solicitGame
local exitGame

-- In-puzzle functions
-- Honestly, the word 'game' in these three
-- function names should be 'puzzle', but I'm
-- too lazy to change it now.
local playGame
local initGame
local gameLoop

-- Input commands during puzzle game loop
-- Invoked by player as alternative to movements.
local undoLastMove
local quitPuzzle
local displayHelp
local solvePuzzle
local displayMoveCount
local resetPuzzle

-- These are functions generated by a factory function
-- that are responsible for getting input from the player.
-- Initialized in initInputGetters().
local getPlayGame
local getPuzzleWidth
local getPuzzleHeight
local getToroidalStatus
local getChoiceInput
local getQuitConfirmation
local getResetConfirmation
local getSolveConfirmation

-- Helper/ancillary functions
local push = function (val, tbl) tbl[#tbl + 1] = val; return #tbl end
local sleep

run = function ()
    print('\nSliding Tile Puzzle Game v1.0 - Terminal version')
    local legalInputs = initLegalInputs()
    initInputGetters(legalInputs)
    solicitGame()
    print('Thanks for playing! Now exiting the game...\n')
end

initLegalInputs = function ()
    local legalInputs = {}
    commandInputsMap  = {['undo'] = undoLastMove,      ['x'] = undoLastMove,
                         ['quit'] = quitPuzzle,        ['q'] = quitPuzzle,
                         ['help'] = displayHelp,       ['h'] = displayHelp,
                         ['moves'] = displayMoveCount, ['m'] = displayMoveCount,
                         ['reset'] = resetPuzzle,      ['z'] = resetPuzzle,
                         ['solve'] = solvePuzzle}

    for k, _ in pairs(TileGrid.movementInputMap) do
        push(k, legalInputs)
    end

    for k, _ in pairs(commandInputsMap) do
        push(k, legalInputs)
    end

    return legalInputs
end

-- These functions could obviously just be defined/set outside of this init function
-- at the top level of the program, but putting them here centralizes where they are
-- and conveniently has all possible methods of user input in one place. I'm also aware
-- this could be optimized further (some of the y/n inputs are quite redundant), but it's
-- simply not needed for such a trivial program.
--
initInputGetters = function (legalInputs)
    local msgInvalidChoice = 'Invalid choice - please try again!'

    getPlayGame = InputGetter.generateInputGetter("\nEnter 'play' (p) to attempt a puzzle, or 'quit' (q) to quit.",
                                                  'Choice: ',
                                                  InputGetter.generateInputValidator('string', {'play', 'p', 'quit', 'q'}),
                                                  msgInvalidChoice)

    getPuzzleWidth = InputGetter.generateInputGetter('Enter the desired width of the puzzle, in number of tiles.',
                                                     'Width: ',
                                                     InputGetter.generateInputValidator('number', nil,
                                                         function (num) return math.type(num) == 'integer' and num > 1 end),
                                                     'Invalid width - please try again!')

    getPuzzleHeight = InputGetter.generateInputGetter('Enter the desired height of the puzzle, in number of tiles.',
                                                      'Height: ',
                                                      InputGetter.generateInputValidator('number', nil,
                                                          function (num) return math.type(num) == 'integer' and num > 1 end),
                                                      'Invalid height - please try again!')

    getToroidalStatus = InputGetter.generateInputGetter("Should the puzzle be toroidal? Please enter 'yes' or 'no' (y/n).",
                                                        'Toroidal puzzle: ',
                                                        InputGetter.generateInputValidator('string', {'yes', 'no', 'y', 'n'}),
                                                        msgInvalidChoice)

    local msgMovement = "\nIn which direction should a tile be slid?\n" ..
                        "\n>> Type a single character from 'wasd' or 'ijkl'" ..
                        "\n>> and then press <enter>. Alternatively, type" ..
                        "\n>> 'help' for additional options.\n"
    getChoiceInput = InputGetter.generateInputGetter(msgMovement, 'Choice: ',
                                                     InputGetter.generateInputValidator('string', legalInputs),
                                                     msgInvalidChoice)

    getQuitConfirmation = InputGetter.generateInputGetter("Are you sure you want to give up on the current puzzle?" ..
                                                          "\nPlease enter 'yes' or 'no' (y/n).",
                                                          'Quiz puzzle?: ',
                                                          InputGetter.generateInputValidator('string', {'yes', 'no', 'y', 'n'}),
                                                          msgInvalidChoice)

    getResetConfirmation = InputGetter.generateInputGetter("Are you sure you want to reset the current puzzle to its original state?" ..
                                                          "\nPlease enter 'yes' or 'no' (y/n).",
                                                          'Reset puzzle?: ',
                                                          InputGetter.generateInputValidator('string', {'yes', 'no', 'y', 'n'}),
                                                          msgInvalidChoice)

    getSolveConfirmation = InputGetter.generateInputGetter("Are you sure you want to the CPU to solve the puzzle?" ..
                                                           "\nPlease enter 'yes' or 'no' (y/n).",
                                                           'Solve puzzle?: ',
                                                           InputGetter.generateInputValidator('string', {'yes', 'no', 'y', 'n'}),
                                                           msgInvalidChoice)

end

solicitGame = function ()
    while (true) do
        local playChoice = getPlayGame()
        if playChoice == 'play' or playChoice == 'p' then
            playGame()
        else
            break
        end
    end
end

playGame = function ()
    local puzzle = initGame()
    gameLoop(puzzle)
    exitGame()
end

initGame = function ()
    local width = getPuzzleWidth()
    local height = getPuzzleHeight()
    local isToroidal = getToroidalStatus()

    if isToroidal == 'yes' or isToroidal == 'y' then
        isToroidal = true
    else
        isToroidal = false
    end

    return TileGrid.new(height, width, isToroidal)
end

-- f: (TileGrid) -> ()
gameLoop = function (puzzle)
    disorder(puzzle)
    local puzzleCopyForReset = puzzle:deepCopy()
    local playerMoveCount = 0

    puzzle:display()

    while (not puzzle:isInWinState()) do
        local choiceInput = getChoiceInput()

        -- If the input wasn't intended to be a command, then it
        -- was intended to be a tile slide/move. Hence the 'else' here.
        if commandInputsMap[choiceInput] then
            local commandResult, extraData = commandInputsMap[choiceInput](puzzle, playerMoveCount)

            if commandResult == '_QUIT' then
                return
            elseif commandResult == '_UNDO_SUCCESSFUL' then
                playerMoveCount = extraData
            elseif commandResult == '_RESET' then
                puzzle = puzzleCopyForReset:deepCopy()
                playerMoveCount = 0
            elseif commandResult == '_SOLVED' then
                print('The puzzle has been solved!')
                return
            end

            puzzle:display()
        else
            local moveWasPossible = puzzle:move(choiceInput)
            if moveWasPossible then playerMoveCount = playerMoveCount + 1 end
            puzzle:display()
            if not moveWasPossible then print ("\nMovement '" .. choiceInput .. "' is not valid. Try another!") end
        end

   end

    print('\nCongratulations - you solved the puzzle! Hooray!')
    print('You solved the puzzle in ' .. playerMoveCount .. ' moves.')
end

exitGame = function ()
    print('\nCurrent puzzle concluded.\nWould you like to attempt another puzzle?')
end

undoLastMove = function (tileGrid, playerMoveCount)
    if playerMoveCount > 0 then
        tileGrid:undo()
        return '_UNDO_SUCCESSFUL', playerMoveCount - 1
    else
        print('No player moves exist to undo!\n')
    end
end

quitPuzzle = function ()
    local choice = getQuitConfirmation()

    if choice == 'yes' or choice == 'y' then
        print('Now quitting the current puzzle...')
        return '_QUIT'
    end

    print('Quit aborted. Resuming the puzzle...\n')
end

local helpMsg = [[
  Controls: Type a single character from 'wasd' or from
            'ijkl' and then press <enter> to move a tile
            that is adjacent to the 'empty tile'.
            Also, 'up', 'down', 'left', and 'right' may
            be entered to move as well.

  Additional commands:
            'quit'  or 'q' -> Quit the current puzzle.
            'undo'  or 'x' -> Undo the last move made.
            'help'  or 'h' -> Display this help message.
            'moves' or 'm' -> Display the number of moves made.
            'solve'        -> Reveal the solution to the puzzle.
]]

displayHelp = function ()
    print(helpMsg)
end

solvePuzzle = function (puzzle, playerMoveCount)
    local choice = getSolveConfirmation()

    if choice == 'no' or choice == 'n' then
        print('Solve aborted. Resuming the current puzzle...\n')
        return
    end

    for i = playerMoveCount, 1, -1 do
        puzzle:undo()
        playerMoveCount = playerMoveCount - 1
        puzzle:display()
        sleep(0.25)
        if puzzle:isInWinState() then return '_SOLVED' end
    end

    for i = 1, #puzzle._moveHistory do
        puzzle:undo()
        puzzle:display()
        sleep(0.25)
        if puzzle:isInWinState() then return '_SOLVED' end
    end
end

displayMoveCount = function(_, playerMoveCount)
    print('# of moves made by player: ' .. playerMoveCount .. '\n')
end

resetPuzzle = function()
    local choice = getResetConfirmation()

    if choice == 'yes' or choice == 'y' then
        print('Now resetting the current puzzle to its original state...\n')
        return '_RESET'
    end

    print('Reset aborted. Resuming the current puzzle...\n')
end

-- It's crude, but it gets the job done in a platform-agnostic manner.
sleep = function (desiredSeconds)
    local elapsedCPUSeconds = os.clock()
    while os.clock() - elapsedCPUSeconds < desiredSeconds do
        -- absolutely nothing
    end
end

run()
